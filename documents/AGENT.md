### AGENT.md
```markdown
# AGENT INSTRUCTIONS: REPO-RUNNER

**System Role:** You are an AI Agent interacting with a codebase. Do not read the raw filesystem directly if `repo-runner` is available. Use `repo-runner` to obtain deterministic, token-budgeted, and topologically accurate codebase context.

## 1. Core Concepts

`repo-runner` freezes dynamic repositories into static, append-only snapshots. It builds a dependency graph and extracts symbols.

### Stable IDs
Never guess file paths. Always use the deterministic Stable IDs generated by the system:
*   **File ID:** `file:{repo-relative-path}` (e.g., `file:src/main.py`). Always lowercase, forward-slash only.
*   **Symbol ID:** `symbol:{ClassName_or_FunctionName}` (e.g., `symbol:GraphBuilder`). 
*   **External ID:** `external:{package_name}` (e.g., `external:react`).

---

## 2. Standard Operating Procedures (SOPs)

### SOP A: Indexing the Repository (Snapshot)
Before doing any deep architectural work, ensure you have an up-to-date snapshot.

**Command:**
```bash
python -m src.entry_point snapshot --output-root ./snapshots .
```
**Expected Output:** A timestamped folder (e.g., `./snapshots/2026-02-22T20-48-32Z`) containing the canonical JSON artifacts.

### SOP B: Targeted Context Gathering (Slicing)
Do not request entire repositories. Use the `slice` command to fetch a targeted Markdown export centered on a specific file or symbol, expanded by dependency edges.

**Command:**
```bash
python -m src.entry_point slice --repo-root . --output-root ./snapshots --snapshot-id current --focus "symbol:TargetClass" --radius 1 --max-tokens 8000
```
*Rules for Slicing:*
*   **Focus:** Can be a `file:...` or `symbol:...`.
*   **Radius:** Start with `1` (immediate imports/dependents). Expand to `2` only if context is missing.
*   **Max Tokens:** Always set a budget (e.g., `8000`) to prevent context overflow. The system uses language-aware weights (e.g., Python is ~3.5 chars/token).

### SOP C: Verifying Changes (Diff)
If you or a user modifies the codebase, take a new snapshot and compare it to the previous one to verify your structural impact.

**Command:**
```bash
python -m src.entry_point diff --base {old_snapshot_id} --target current --output-root ./snapshots
```
**Expected Output:** A summary of added/removed/modified files and edges.

---

## 3. Understanding the Artifacts

If you must read the raw JSON outputs within a snapshot folder:

1.  **`manifest.json`**: The ground truth. Contains file hashes, sizes, and raw imports.
2.  **`graph.json`**: The topological map. Look here for `has_cycles: true/false`. If cycles exist, navigate carefully to avoid infinite loops.
3.  **`symbols.json`**: The global index. Maps `{"ClassName": ["file:path/..."]}`. Use this to find where things are defined.
4.  **`structure.json`**: The hierarchical tree. Use this to understand directory layout without touching the OS.

---

## 4. Agent Constraints (CRITICAL)

1.  **Append-Only:** Never attempt to overwrite a snapshot folder. They are immutable.
2.  **Trust the Telemetry:** If a slice returns `Usage: 7900/8000 tokens`, do not request a wider radius. You are at the edge of your context window.
3.  **Do Not Parse Imports Yourself:** Rely on the `edges` in `graph.json`. `repo-runner` handles complex multi-line, lazy, and aliased imports via AST/Regex extraction.
```
